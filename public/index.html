<html>
<head>

<script src="../library/p5.js"></script>
    <script>
    var pagePrime = "";
    function httpGetAsync(theUrl, callback)
    {
        var xmlHttp = new XMLHttpRequest();
        xmlHttp.onreadystatechange = function() {
            if (xmlHttp.readyState == 4 && xmlHttp.status == 200)
                callback(xmlHttp.responseText);
        }
        xmlHttp.open("GET", theUrl, true); // true for asynchronous
        xmlHttp.send(null);
    }
    var voyelles = ['a', 'e', 'i', 'o', 'u'];
    var iterations = 2;
    var widthCanvas = 1920;
    var heightCanvas = 1080;
    var CustomRandom = function(nseed) {

        var seed,
            constant = Math.pow(2, 13)+1,
            prime = 1987,
//any prime number, needed for calculations, 1987 is my favorite:)
            maximum = 1000;
//maximum number needed for calculation the float precision of the numbers (10^n where n is number of digits after dot)
        if (nseed) {
            seed = nseed;
        }

        if (seed == null) {
//before you will correct me in this comparison, read Andrea Giammarchi's text about coercion http://goo.gl/N4jCB

            seed = (new Date()).getTime();
//if there is no seed, use timestamp
        }

        return {
            next : function(min, max) {
                seed *= constant;
                seed += prime;


                return min && max ? min+seed%maximum/maximum*(max-min) : seed%maximum/maximum;
// if 'min' and 'max' are not provided, return random number between 0 & 1
            }
        }
    }

    async function ResolveTable(page, curve, i, length, randomNb)
    {
        var rng = CustomRandom(length * i);

                    // var i = 0;
        // pixelDensity(5);
        // pixelDensity(9.5);
        // if (page[i] == ' ')
            stroke(0);
            fill(0);
            rect(i / 10, length / 20, 5, 5);
        // }
        // else// if (page[i] == ',')
        // {
            var oldPosition = [[((i) / widthCanvas + (widthCanvas / 2)) % widthCanvas, ((length) / heightCanvas + (heightCanvas / 2)) % heightCanvas], [((i) / widthCanvas + (widthCanvas / 2)) % widthCanvas, ((length) / heightCanvas + (heightCanvas / 2)) % heightCanvas]];
            i = 0;
            var split = 1;
            var initPos = oldPosition[0];
            stroke(0);
            fill(0, 0, 0, 0);
            noFill();

            var tmpSplit = 0;
            var incrementAngle = 90;
            var radius = 5;
            var angle = 0;
            beginShape();
            var tmpPos = [];
            var tmpCircle = [];
            strokeWeight(0.05);

        while (i < page.length) {
                // var value = ((float)(page[i].charCodeAt(0) % 28) / 28 + i % 32 / 32) * 127;
                stroke(0);
                //fill('rgba(127,127,127, 0.1)');
                //fill(value, value, value, value / 5);
                //                      stroke(sin((float)(page[i].charCodeAt(0)) + 1) * 255, (cos((float)(page[i].charCodeAt(0))) + 1) * 255, (sin((float)(page[i].charCodeAt(0)) * cos((float)(page[i].charCodeAt(0)))) + 2) * 255);

                switch (page[i]) {
                    case ',':
                        while (page[i] == ',' && i < page.length) {
                            split++;
                            i++;
                        }
                        break;
                    case '-':
                        while (page[i] == '-' && i < page.length) {
                            angle = (angle - incrementAngle) % 360;
                            tmpCircle = [radius * cos(angle * Math.PI / 180), radius * sin(angle * Math.PI / 180)];
                            i++;
                        }
                        break;
                    case '+':
                        while (page[i] == '+' && i < page.length) {
                            angle = (angle + incrementAngle) % 360;
                            tmpCircle = [radius * cos(angle * Math.PI / 180), radius * sin(angle * Math.PI / 180)];
                            i++;
                        }
                        break;
                    case 'f':
                        incrementAngle = 120;
                        while (page[i] == 'f' && i < page.length) {
                            // tmpPos = [(oldPosition[0][0] + tmpCircle[0]) % widthCanvas, (oldPosition[0][1] + tmpCircle[1]) % heightCanvas];
//                                    line(oldPosition[0][0], oldPosition[0][1], (oldPosition[0][0] + radius * cos(angle * Math.PI / 180)) % widthCanvas, (oldPosition[0][1] + radius * sin(angle * Math.PI / 180)) % heightCanvas);
                            for (var j = 0; j < split; j++) {
                                if (!curve) {
                                    // tmpPos = [(oldPosition[0][0] + tmpCircle[0]), (oldPosition[0][1] + tmpCircle[1])];
                                    tmpPos = [(oldPosition[0][0] + tmpCircle[0]) % widthCanvas, (oldPosition[0][1] + tmpCircle[1]) % heightCanvas];
                                    vertex(tmpPos[0], tmpPos[1]);
                                } else {
                                    tmpPos = [(oldPosition[0][0] + tmpCircle[0] + randomNb) % widthCanvas, (oldPosition[0][1] + tmpCircle[1] + randomNb) % heightCanvas];
                                    // tmpPos = [(oldPosition[0][0] + tmpCircle[0] + randomNb), (oldPosition[0][1] + tmpCircle[1] + randomNb)];
                                    curveVertex(tmpPos[0], tmpPos[1]);
                                }
                                oldPosition[0] = tmpPos;
                            }
                            i++;
                        }
                        break;
                    case 'b':
                        while (page[i] == 'b' && i < page.length) {
                            // tmpPos = [(oldPosition[0][0] + tmpCircle[0]) % widthCanvas, (oldPosition[0][1] + tmpCircle[1]) % heightCanvas];
//                                      line(oldPosition[0][0], oldPosition[0][1], (oldPosition[0][0] + radius * cos(angle * Math.PI / 180)) % widthCanvas, (oldPosition[0][1] + radius * sin(angle * Math.PI / 180)) % heightCanvas);
                            for (var j = 0; j < split; j++) {
                                if (!curve) {
                                    tmpPos = [(oldPosition[0][0] + tmpCircle[0]) % widthCanvas, (oldPosition[0][1] + tmpCircle[1]) % heightCanvas];
                                    // tmpPos = [(oldPosition[0][0] + tmpCircle[0]), (oldPosition[0][1] + tmpCircle[1])];
                                    vertex(tmpPos[0], tmpPos[1]);
                                } else {
                                    tmpPos = [(oldPosition[0][0] + tmpCircle[0] + randomNb) % widthCanvas, (oldPosition[0][1] + tmpCircle[1] + randomNb) % heightCanvas];
                                    // tmpPos = [(oldPosition[0][0] + tmpCircle[0] + randomNb), (oldPosition[0][1] + tmpCircle[1] + randomNb)];
                                    curveVertex(tmpPos[0], tmpPos[1]);
                                }
                                oldPosition[0] = tmpPos;
                            }
                            i++;
                        }
                        break;
                    case 'c':
                        while (page[i] == 'c' && i < page.length) {
                            for (var j = 0; j < split; j++) {
                                if (curve)
                                // oldPosition[0] = [(oldPosition[0][0] + tmpCircle[0]), (oldPosition[0][1] + tmpCircle[1])];
                                    oldPosition[0] = [(oldPosition[0][0] + tmpCircle[0]) % widthCanvas, (oldPosition[0][1] + tmpCircle[1]) % heightCanvas];
                                else
                                // oldPosition[0] = [(oldPosition[0][0] + tmpCircle[0] + randomNb), (oldPosition[0][1] + tmpCircle[1] + randomNb)];
                                    oldPosition[0] = [(oldPosition[0][0] + tmpCircle[0] + randomNb) % widthCanvas, (oldPosition[0][1] + tmpCircle[1] + randomNb) % heightCanvas];
                            }
                            i++;
                        }
                        break;
                    case 'd':
                        incrementAngle = 60;
                        while (page[i] == 'd' && i < page.length) {
                            //                                  line(oldPosition[0][0], oldPosition[0][1], (oldPosition[0][0] + radius * cos(angle * Math.PI / 180)) % widthCanvas, (oldPosition[0][1] + radius * sin(angle * Math.PI / 180)) % heightCanvas);
                            // tmpPos = [(oldPosition[0][0] + tmpCircle[0]) % widthCanvas, (oldPosition[0][1] + tmpCircle[1]) % heightCanvas];
                            for (var j = 0; j < split; j++) {
                                if (!curve) {
                                    tmpPos = [(oldPosition[0][0] + tmpCircle[0]) % widthCanvas, (oldPosition[0][1] + tmpCircle[1]) % heightCanvas];
                                    // tmpPos = [(oldPosition[0][0] + tmpCircle[0]), (oldPosition[0][1] + tmpCircle[1])];
                                    vertex(tmpPos[0], tmpPos[1]);
                                } else {
                                    tmpPos = [(oldPosition[0][0] + tmpCircle[0] + randomNb) % widthCanvas, (oldPosition[0][1] + tmpCircle[1] + randomNb) % heightCanvas];
                                    // tmpPos = [(oldPosition[0][0] + tmpCircle[0] + randomNb), (oldPosition[0][1] + tmpCircle[1] + randomNb)];
                                    curveVertex(tmpPos[0], tmpPos[1]);
                                }
                                oldPosition[0] = tmpPos;
                            }
                            i++;
                        }
                        break;
                    case 'h':
                        incrementAngle = 90;
                        while (page[i] == 'h' && i < page.length) {
                            //                                    line(oldPosition[0][0], oldPosition[0][1], (oldPosition[0][0] + radius * cos(angle * Math.PI / 180)) % widthCanvas, (oldPosition[0][1] + radius * sin(angle * Math.PI / 180)) % heightCanvas);
                            // tmpPos = [(oldPosition[0][0] + tmpCircle[0]) % widthCanvas, (oldPosition[0][1] + tmpCircle[1]) % heightCanvas];
                            for (var j = 0; j < split; j++) {

                                if (!curve) {
                                    // tmpPos = [(oldPosition[0][0] + tmpCircle[0]), (oldPosition[0][1] + tmpCircle[1])];
                                    tmpPos = [(oldPosition[0][0] + tmpCircle[0]) % widthCanvas, (oldPosition[0][1] + tmpCircle[1]) % heightCanvas];
                                    vertex(tmpPos[0], tmpPos[1]);
                                } else {
                                    tmpPos = [(oldPosition[0][0] + tmpCircle[0] + randomNb) % widthCanvas, (oldPosition[0][1] + tmpCircle[1] + randomNb) % heightCanvas];
                                    // tmpPos = [(oldPosition[0][0] + tmpCircle[0] + randomNb), (oldPosition[0][1] + tmpCircle[1] + randomNb)];
                                    curveVertex(tmpPos[0], tmpPos[1]);
                                }
                                oldPosition[0] = tmpPos;
                            }
                            i++;
                        }
                        break;
                    case 'j':
                        incrementAngle = 60;
                        while (page[i] == 'j' && i < page.length) {
//                                    line(oldPosition[0][0], oldPosition[0][1], (oldPosition[0][0] + radius * cos(angle * Math.PI / 180)) % widthCanvas, (oldPosition[0][1] + radius * sin(angle * Math.PI / 180)) % heightCanvas);
//                             tmpPos = [(oldPosition[0][0] + tmpCircle[0]) % widthCanvas, (oldPosition[0][1] + tmpCircle[1]) % heightCanvas];
                            for (var j = 0; j < split; j++) {
                                if (!curve) {
                                    // tmpPos = [(oldPosition[0][0] + tmpCircle[0]), (oldPosition[0][1] + tmpCircle[1])];
                                    tmpPos = [(oldPosition[0][0] + tmpCircle[0]) % widthCanvas, (oldPosition[0][1] + tmpCircle[1]) % heightCanvas];
                                    vertex(tmpPos[0], tmpPos[1]);
                                } else {
                                    tmpPos = [(oldPosition[0][0] + tmpCircle[0] + randomNb) % widthCanvas, (oldPosition[0][1] + tmpCircle[1] + randomNb) % heightCanvas];
                                    // tmpPos = [(oldPosition[0][0] + tmpCircle[0] + randomNb), (oldPosition[0][1] + tmpCircle[1] + randomNb)];
                                    curveVertex(tmpPos[0], tmpPos[1]);
                                }
                                oldPosition[0] = tmpPos;
                            }
                            i++
                        }
                        break;
                    case 'k':
                        incrementAngle = 60;
                        while (page[i] == 'k' && i < page.length) {
//                                    line(oldPosition[0][0], oldPosition[0][1], (oldPosition[0][0] + radius * cos(angle * Math.PI / 180)) % widthCanvas, (oldPosition[0][1] + radius * sin(angle * Math.PI / 180)) % heightCanvas);
                            for (var j = 0; j < split; j++) {
                                if (!curve) {
                                    // tmpPos = [(oldPosition[0][0] + tmpCircle[0]), (oldPosition[0][1] + tmpCircle[1])];
                                    tmpPos = [(oldPosition[0][0] + tmpCircle[0]) % widthCanvas, (oldPosition[0][1] + tmpCircle[1]) % heightCanvas];
                                    vertex(tmpPos[0], tmpPos[1]);
                                } else {
                                    tmpPos = [(oldPosition[0][0] + tmpCircle[0] + randomNb) % widthCanvas, (oldPosition[0][1] + tmpCircle[1] + randomNb) % heightCanvas];
                                    // tmpPos = [(oldPosition[0][0] + tmpCircle[0] + randomNb), (oldPosition[0][1] + tmpCircle[1] + randomNb)];
                                    curveVertex(tmpPos[0], tmpPos[1]);
                                }
                                oldPosition[0] = tmpPos;
                            }
                            i++;
                        }
                        break;
                    case 'l':
                        while (page[i] == 'l' && i < page.length) {
                            i++;
                        }
                        break;
                    case 'g':
                        incrementAngle = 120;
                        while (page[i] == 'g' && i < page.length) {
//                                    line(oldPosition[0][0], oldPosition[0][1], (oldPosition[0][0] + radius * cos(angle * Math.PI / 180)) % widthCanvas, (oldPosition[0][1] + radius * sin(angle * Math.PI / 180)) % heightCanvas);
                            for (var j = 0; j < split; j++) {
                                if (!curve) {
                                    // tmpPos = [(oldPosition[0][0] + tmpCircle[0]), (oldPosition[0][1] + tmpCircle[1])];
                                    tmpPos = [(oldPosition[0][0] + tmpCircle[0]) % widthCanvas, (oldPosition[0][1] + tmpCircle[1]) % heightCanvas];
                                    vertex(tmpPos[0], tmpPos[1]);
                                } else {
                                    tmpPos = [(oldPosition[0][0] + tmpCircle[0] + randomNb) % widthCanvas, (oldPosition[0][1] + tmpCircle[1] + randomNb) % heightCanvas];
                                    // tmpPos = [(oldPosition[0][0] + tmpCircle[0] + randomNb), (oldPosition[0][1] + tmpCircle[1] + randomNb)];
                                    curveVertex(tmpPos[0], tmpPos[1]);
                                }
                                oldPosition[0] = tmpPos;
                            }
                            i++;
                        }
                        break;
                    case 'm':

                        radius = 20;
                        tmpCircle = [radius * cos(angle * Math.PI / 180), radius * sin(angle * Math.PI / 180)];
                        while (page[i] == 'm' && i < page.length) {
                            i++;
                        }
                        break;
                    case 'n':
                        radius = 2;
                        tmpCircle = [radius * cos(angle * Math.PI / 180), radius * sin(angle * Math.PI / 180)];
                        while (page[i] == 'n' && i < page.length) {
                            i++;
                        }
                        break;
                    case 'p':
                        radius = 1;
                        tmpCircle = [radius * cos(angle * Math.PI / 180), radius * sin(angle * Math.PI / 180)];
                        while (page[i] == 'p' && i < page.length) {
                            i++;
                        }
                        break;
                    case 'q':
                        radius = 5;
                        tmpCircle = [radius * cos(angle * Math.PI / 180), radius * sin(angle * Math.PI / 180)];
                        while (page[i] == 'q' && i < page.length) {
                            i++;
                        }
                        break;
                    case 'r':
                        radius = 10;
                        tmpCircle = [radius * cos(angle * Math.PI / 180), radius * sin(angle * Math.PI / 180)];
                        while (page[i] == 'r' && i < page.length) {
                            i++;
                        }
                        break;
                    case 's':
                        radius = 15;
                        tmpCircle = [radius * cos(angle * Math.PI / 180), radius * sin(angle * Math.PI / 180)];
                        while (page[i] == 's' && i < page.length) {
                            i++;
                        }
                        break;
                    case 't':
                        radius = 8;
                        tmpCircle = [radius * cos(angle * Math.PI / 180), radius * sin(angle * Math.PI / 180)];
                        while (page[i] == 't' && i < page.length) {
                            i++;
                        }
                        break;
                    case 'u':
                        radius = 12;
                        tmpCircle = [radius * cos(angle * Math.PI / 180), radius * sin(angle * Math.PI / 180)];
                        while (page[i] == 'u' && i < page.length) {
                            i++;
                        }
                        break;
                    default:
                        i++;
                        break;
                }
                // i++;
            }
            //vertex(initPos[0], initPos[1]);
            endShape();
        // }
        //return new Promise(resolve => console.log("test"));
    }

    async function parallelSplit(page)
    {
        var splitTable = page.split(' ');
        console.log(splitTable.length);
        // background(255);
        var tableFunctions = [];
        var nb = 10;
        var index = 0;
        var randomNb = [];
        for (var i = 0; i < nb; i++) {
            tableFunctions[i] = [];
            index = (-100 * splitTable.length) / 2;
            for (var j = 0; j < splitTable.length; j++) {
                randomNb[j] = Math.random() - 0.5;
                if (i == 0) {
                    ResolveTable(splitTable[j], false, index, splitTable[j].length * 120, randomNb[j]);
                }
                else
                    ResolveTable(splitTable[j], true, index, splitTable[j].length * 120, randomNb[j]);
                index += 100;
            }
            // if (i < nb - 1)
                // Promise.all(tableFunctions[i]);
        }
        // await Promise.all(tableFunctions[nb - 1]);
        //console.log("After" + j);
    }

    function setup()
    {
        httpGetAsync("/page?search=" + document.getElementById("search").value, function(data) {
            //page = data;
            createCanvas(widthCanvas, heightCanvas);

            pagePrime = data.replace(/y/g, "z").replace(/z/g, "aeiou").replace(/a/g, "bcd").replace(/e/g, "fgh").replace(/i/g, "jklmn").replace(/o/g, "pqrst").replace(/u/g, "vwx");
            //for (var index1 = 0; index1 < iterations; index1++)
            //    page = page.replace(/y/g, "z").replace(/z/g, "aeiou").replace(/a/g, "bcd").replace(/e/g, "fgh").replace(/i/g, "jklmn").replace(/o/g, "pqrst").replace(/u/g, "vwx");
            for (var index2 = 0; index2 <= iterations; index2++)
                pagePrime = pagePrime.replace(/b/g, "bcb").replace(/c/g, "ccc").replace(/d/g, "d-g+d+g-g").replace(/f/g, "f+f-f-f+f").replace(/g/g, "gg")
                        .replace(/h/g, "h").replace(/j/g, "k-j-k").replace(/k/g, "j+k+j").replace(/l/g, "l").replace(/m/g, "m")
                        .replace(/n/g, "n").replace(/p/g, "p").replace(/q/g, "q").replace(/r/g, "r").replace(/s/g, "s")
                        .replace(/t/g, "t").replace(/u/g, "u").replace(/v/g, "v+wh+").replace(/w/g, "-hv-w").replace(/x/g, "x");
            parallelSplit(pagePrime);

        });
    }

</script>
</head>
<body>
<input type="text" name="Search" id="search" value=""><br>
<input type="submit" value="Submit" onclick="setup()">
</body>
</html>